// Copyright 2020 Torben Schinke
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package src

import (
	"strconv"
	"strings"
)

type FileBuilder struct {
	namedImports map[string]string // path => named import alias
	types        []*TypeBuilder
	funcs        []*FuncBuilder
	pkgName      string
	genHeader    string
	doc          string
	importPath   string //optional, will help to avoid illegal self imports
	vars         []*VarBuilder
}

func NewFile(pkgName string) *FileBuilder {
	return &FileBuilder{namedImports: map[string]string{}, pkgName: pkgName}
}

func (b *FileBuilder) File() *FileBuilder {
	return b
}

func (b *FileBuilder) SetImportPath(path string) *FileBuilder {
	b.importPath = path
	return b
}

func (b *FileBuilder) AddTypes(types ...*TypeBuilder) *FileBuilder {
	b.types = append(b.types, types...)
	for _, t := range types {
		t.onAttach(b)
	}

	return b
}

// AddVars appends package global variables. They are rendered right after the import statements.
func (b *FileBuilder) AddVars(vars ...*VarBuilder) *FileBuilder {
	b.vars = append(b.vars, vars...)
	for _, v := range vars {
		v.onAttach(b)
	}
	return b
}

// Vars returns the current variables.
func (b *FileBuilder) Vars() []*VarBuilder {
	return b.vars
}

// Types returns the underlying slice of registered types.
func (b *FileBuilder) Types() []*TypeBuilder {
	return b.types
}

// TypeByName returns either the first type with the given name or nil.
func (b *FileBuilder) TypeByName(name string) *TypeBuilder {
	for _, typ := range b.types {
		if typ.name == name {
			return typ
		}
	}
	return nil
}

func (b *FileBuilder) AddFuncs(funcs ...*FuncBuilder) *FileBuilder {
	b.funcs = append(b.funcs, funcs...)
	for _, builder := range funcs {
		builder.onAttach(b)
	}

	return b
}

// Funcs returns the underlying slice of registered functions.
func (b *FileBuilder) Funcs() []*FuncBuilder {
	return b.funcs
}

// FuncByName returns the first matching function by name or nil.
func (b *FileBuilder) FuncByName(name string) *FuncBuilder {
	for _, fun := range b.funcs {
		if fun.name == name {
			return fun
		}
	}
	return nil
}

func (b *FileBuilder) SetPackageDoc(doc string) *FileBuilder {
	b.doc = doc
	return b
}

// Use introduces the given qualifier and performs a named import and returns a string which consists of
// <prefix>.<name> or just the name for universe types.
func (b *FileBuilder) Use(q Qualifier) string {
	// universe scope has just the . and does not need any import
	if q.Path() == "" {
		return q.Name()
	}

	if b == nil {
		return string(q)
	}

	// fix illegal self-imports, if we can
	if b.importPath != "" && strings.HasPrefix(string(q), b.importPath+".") {
		return q.Name()
	}

	if name, has := b.namedImports[q.Path()]; has {
		return name + "." + q.Name()
	}

	for i := 0; i >= 0; i++ {
		nextName := sanitizeName(strings.ToLower(lastName(q.Path())))
		if i > 0 {
			if i == 1 {
				// be more clever on collision and use a nicer addition of the path name before the last one
				nextName = sanitizeName(strings.ToLower(lastlastName(q.Path()) + lastName(q.Path())))
			} else {
				nextName += strconv.Itoa(i)
			}
		}

		if !b.hasImportAlias(nextName) {
			b.namedImports[q.Path()] = nextName
			return nextName + "." + q.Name()
		}
	}

	panic("invalid state")
}

func (b *FileBuilder) hasImportAlias(a string) bool {
	for _, v := range b.namedImports {
		if v == a {
			return true
		}
	}

	return false
}

func (b *FileBuilder) SetGeneratorName(name string) *FileBuilder {
	b.genHeader = "// Code generated by " + name + ". DO NOT EDIT.\n\n"
	return b
}

func (b *FileBuilder) Emit(w Writer) {

	tmp := &BufferedWriter{}
	for _, v := range b.vars {
		v.Emit(tmp)
		w.Printf("\n")
	}

	for _, t := range b.types {
		t.Emit(tmp)
	}

	for _, t := range b.funcs {
		t.Emit(tmp)
	}

	if b.genHeader != "" {
		w.Printf(b.genHeader)
	}

	emitDoc(w, "", b.doc)

	w.Printf("package %s\n\n", b.pkgName)
	if len(b.namedImports) > 0 {
		w.Printf("import(\n")
		for path, name := range b.namedImports {
			w.Printf("%s \"%s\"\n", name, path)
		}
		w.Printf(")\n")
	}

	w.Printf(tmp.String())
}

func (b *FileBuilder) String() string {
	w := &BufferedWriter{}
	b.Emit(w)
	str, err := w.Format()
	if err != nil {
		return str + "\n" + err.Error()
	}

	return str
}

func lastName(text string) string {
	tokens := strings.Split(text, "/")
	pkgname := text
	if len(tokens) > 0 {
		pkgname = tokens[len(tokens)-1]
	}
	return pkgname
}

func lastlastName(text string) string {
	tokens := strings.Split(text, "/")
	pkgname := text
	if len(tokens) > 1 {
		pkgname = tokens[len(tokens)-2]
	}
	return pkgname
}

func sanitizeName(text string) string {
	sb := &strings.Builder{}
	for _, r := range text {
		if r >= 'a' && r <= 'z' {
			sb.WriteRune(r)
		}
	}

	return sb.String()
}

type FileProvider interface {
	File() *FileBuilder
}
