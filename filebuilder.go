// Copyright 2020 Torben Schinke
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package src

import (
	"strconv"
	"strings"
)

type FileBuilder struct {
	namedImports map[string]string // path => named import alias
	types        []*TypeBuilder
	pkgName      string
	genHeader    string
	doc          string
}

func NewFile(pkgName string) *FileBuilder {
	return &FileBuilder{namedImports: map[string]string{}, pkgName: pkgName}
}

func (b *FileBuilder) AddTypes(types ...*TypeBuilder) *FileBuilder {
	b.types = append(b.types, types...)
	for _, t := range types {
		t.onAttach(b)
	}

	return b
}

func (b *FileBuilder) SetPackageDoc(doc string) *FileBuilder {
	b.doc = doc
	return b
}

// Use introduces the given qualifier and performs a named import and returns a string which consists of
// <prefix>.<name> or just the name for universe types.
func (b *FileBuilder) Use(q Qualifier) string {
	// universe scope has just the . and does not need any import
	if q.Path() == "" {
		return q.Name()
	}

	if b == nil {
		return string(q)
	}

	if name, has := b.namedImports[q.Path()]; has {
		return name + "." + q.Name()
	}

	for i := 0; i >= 0; i++ {
		nextName := sanitizeName(strings.ToLower(lastName(q.Path())))
		if i > 0 {
			nextName += strconv.Itoa(i)
		}

		if !b.hasImportAlias(nextName) {
			b.namedImports[q.Path()] = nextName
			return nextName + "." + q.Name()
		}
	}

	panic("invalid state")
}

func (b *FileBuilder) hasImportAlias(a string) bool {
	for _, v := range b.namedImports {
		if v == a {
			return true
		}
	}

	return false
}

func (b *FileBuilder) SetGeneratorName(name string) *FileBuilder {
	b.genHeader = "// Code generated by " + name + ". DO NOT EDIT.\n\n"
	return b
}

func (b *FileBuilder) Emit(w Writer) {

	tmp := &BufferedWriter{}
	for _, t := range b.types {
		t.Emit(tmp)
	}

	if b.genHeader != "" {
		w.Printf(b.genHeader)
	}

	emitDoc(w, "", b.doc)

	w.Printf("package %s\n\n", b.pkgName)
	if len(b.namedImports) > 0 {
		w.Printf("import(\n")
		for path, name := range b.namedImports {
			w.Printf("%s \"%s\"\n", name, path)
		}
		w.Printf(")\n")
	}

	w.Printf(tmp.String())
}

func (b *FileBuilder) String() string {
	w := &BufferedWriter{}
	b.Emit(w)
	str, err := w.Format()
	if err != nil {
		return str + "\n" + err.Error()
	}

	return str
}

func lastName(text string) string {
	tokens := strings.Split(text, "/")
	pkgname := text
	if len(tokens) > 0 {
		pkgname = tokens[len(tokens)-1]
	}
	return pkgname
}

func sanitizeName(text string) string {
	sb := &strings.Builder{}
	for _, r := range text {
		if r >= 'a' && r <= 'z' {
			sb.WriteRune(r)
		}
	}

	return sb.String()
}

type FileProvider interface {
	File() *FileBuilder
}
